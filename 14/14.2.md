# Clean Architecture на Go

**Clean Architecture** — это способ организации кода так, чтобы **бизнес-логика была независима от деталей реализации**, таких как база данных, веб-фреймворки или внешние сервисы.

Идея проста: **код должен быть понятным, тестируемым и легко расширяемым**.

---

### Основные принципы

1. **Слойность**

   * Бизнес-логика (Entities / Domain) находится в центре.
   * Снаружи — интерфейсы для взаимодействия с внешним миром (HTTP, БД, очередь).

2. **Зависимости направлены внутрь**

   * Внутренние слои не зависят от внешних.
   * Например, доменные модели не должны знать о том, как хранится база данных.

3. **Интерфейсы вместо конкретных реализаций**

   * Слой домена описывает **интерфейсы**, а слой инфраструктуры их реализует.

---

### Типичная структура проекта

```txt
myapp/
├── cmd/
│   └── main.go          # Запуск приложения
├── internal/
│   ├── domain/          # Сущности и бизнес-правила
│   │   └── user.go
│   ├── service/         # Сервисный слой (use cases)
│   │   └── user_service.go
│   ├── repository/      # Интерфейсы репозиториев
│   │   └── user_repo.go
│   └── transport/       # Взаимодействие с внешним миром (HTTP, gRPC)
│       └── http/
│           └── handlers.go
```

---

### Пример: слой домена и репозитория

```go
// domain/user.go
package domain

type User struct {
    ID   int
    Name string
}

// repository/user_repo.go
package repository

import "myapp/internal/domain"

type UserRepository interface {
    GetByID(id int) (*domain.User, error)
    Save(u *domain.User) error
}
```

Сервисный слой использует интерфейс, **не заботясь о конкретной базе данных**:

```go
// service/user_service.go
package service

import "myapp/internal/domain"

type UserService struct {
    repo UserRepository
}

func (s *UserService) GetUserName(id int) (string, error) {
    user, err := s.repo.GetByID(id)
    if err != nil {
        return "", err
    }
    return user.Name, nil
}
```

---

### Преимущества Clean Architecture

✅ **Тестируемость**

* Можно подставлять моки вместо реальных баз данных.

✅ **Масштабируемость**

* Добавление нового способа взаимодействия (HTTP, gRPC, CLI) не ломает бизнес-логику.

✅ **Независимость от фреймворков и библиотек**

* Замена внешних сервисов не требует изменения внутренней логики.

---

### Итог

* Clean Architecture помогает **разделять ответственность** между слоями.
* Основной принцип: **внутренние слои не зависят от внешних**.
* В Go такая архитектура реализуется через **пакеты, интерфейсы и слои domain → service → transport**.