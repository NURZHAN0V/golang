# gRPC и Protocol Buffers

gRPC — это современный фреймворк для **высокопроизводительной коммуникации между сервисами**. Он использует протокол HTTP/2 и **Protocol Buffers (protobuf)** для эффективной сериализации данных.

Go отлично подходит для gRPC благодаря **легковесным горутинам**, встроенной поддержке сетевых соединений и официальной библиотеке `google.golang.org/grpc`.

---

### Что такое Protocol Buffers?

* Protocol Buffers (protobuf) — это **формат сериализации данных**, разработанный Google.
* Он позволяет описывать структуры данных в виде `.proto` файлов.
* Из `.proto` файлов **генерируется код на Go**, который умеет сериализовать и десериализовать сообщения.
* Преимущество: **компактные, быстрые и совместимые между версиями данные**.

Пример `.proto` файла:

```proto
syntax = "proto3";

package example;

message User {
    int32 id = 1;
    string name = 2;
}

service UserService {
    rpc GetUser(UserRequest) returns (User);
}

message UserRequest {
    int32 id = 1;
}
```

* `message` описывает структуру данных.
* `service` описывает **RPC-интерфейс**.
* Каждое поле имеет номер (`= 1`, `= 2`) для совместимости при обновлениях.

---

### Установка инструментов

```bash
go install google.golang.org/protobuf/cmd/protoc-gen-go@latest
go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@latest
```

* `protoc-gen-go` — генерирует структуры Go для сообщений.
* `protoc-gen-go-grpc` — генерирует интерфейсы и клиентский код для сервисов.

---

### Генерация Go-кода

```bash
protoc --go_out=. --go-grpc_out=. user.proto
```

* `--go_out=.` — создаёт Go-структуры для сообщений.
* `--go-grpc_out=.` — создаёт интерфейсы для gRPC-сервера и клиента.

---

### Простейший gRPC-сервер на Go

```go
package main

import (
    "context"
    "log"
    "net"

    pb "example/proto"
    "google.golang.org/grpc"
)

type server struct {
    pb.UnimplementedUserServiceServer
}

func (s *server) GetUser(ctx context.Context, req *pb.UserRequest) (*pb.User, error) {
    return &pb.User{Id: req.Id, Name: "Олег"}, nil
}

func main() {
    lis, err := net.Listen("tcp", ":50051")
    if err != nil {
        log.Fatalf("Ошибка прослушивания: %v", err)
    }

    s := grpc.NewServer()
    pb.RegisterUserServiceServer(s, &server{})

    log.Println("gRPC сервер запущен на :50051")
    if err := s.Serve(lis); err != nil {
        log.Fatalf("Ошибка сервера: %v", err)
    }
}
```

* `pb.UnimplementedUserServiceServer` — встраиваемая структура для защиты интерфейса.
* `GetUser` реализует RPC-метод, который возвращает пользователя.
* Сервер запускается на TCP-порту `:50051`.

---

### Клиент gRPC

```go
package main

import (
    "context"
    "log"
    "time"

    pb "example/proto"
    "google.golang.org/grpc"
)

func main() {
    conn, err := grpc.Dial("localhost:50051", grpc.WithInsecure())
    if err != nil {
        log.Fatalf("Ошибка подключения: %v", err)
    }
    defer conn.Close()

    client := pb.NewUserServiceClient(conn)

    ctx, cancel := context.WithTimeout(context.Background(), time.Second)
    defer cancel()

    resp, err := client.GetUser(ctx, &pb.UserRequest{Id: 1})
    if err != nil {
        log.Fatalf("Ошибка запроса: %v", err)
    }

    log.Printf("Получен пользователь: %v", resp)
}
```

* `grpc.Dial` создаёт соединение с сервером.
* `NewUserServiceClient` создаёт клиент для вызова RPC-методов.
* Контекст (`context.Context`) позволяет задавать **тайм-ауты и отмену** запросов.

---

### Итого

* gRPC + Protocol Buffers — это **быстрый и компактный способ связи между сервисами**.
* Go легко интегрируется с gRPC благодаря **официальной поддержке и горутинам**.
* `.proto` файлы описывают **структуры и сервисы**, из которых генерируется Go-код.
* Подходит для **микросервисов, мобильных приложений и высоконагруженных систем**.