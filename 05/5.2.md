# Замыкания

В Go **замыкания** (closures) — это функции, которые **«помнят» переменные из внешней области видимости**, даже если эта область уже завершила выполнение.

Замыкания позволяют **хранить состояние внутри функции** и использовать его позже, создавая очень удобные и компактные конструкции.

---

### Пример замыкания

```go
func makeCounter() func() int {
    count := 0
    return func() int {
        count++
        return count
    }
}

counter := makeCounter()
fmt.Println(counter()) // 1
fmt.Println(counter()) // 2
fmt.Println(counter()) // 3
```

* Функция `makeCounter` возвращает **анонимную функцию**, которая использует переменную `count`.
* Даже после того, как `makeCounter` завершила работу, `count` **сохраняет своё значение**.
* Так работает **замыкание**: функция «замкнула» переменные из внешней области.

---

### Почему это удобно

1. **Хранение состояния без глобальных переменных**

```go
adder := func(x int) func(int) int {
    sum := x
    return func(y int) int {
        sum += y
        return sum
    }
}(10)

fmt.Println(adder(5))  // 15
fmt.Println(adder(3))  // 18
```

* Внутреннее состояние (`sum`) сохраняется между вызовами.

2. **Функции как фабрики функций**

* Замыкания позволяют создавать **специализированные функции на основе общих шаблонов**.
* Это удобно для конфигурации логики, обработчиков событий или генераторов значений.

---

### Замыкания и анонимные функции

* **Каждое замыкание — это анонимная функция**, которая использует переменные внешней области:

```go
greet := func(name string) func() {
    return func() {
        fmt.Println("Привет,", name)
    }
}

sayHello := greet("Олег")
sayHello() // Привет, Олег
```

* Такой приём часто используется для **инкапсуляции логики и состояния**.

---

### Важно помнить

* Замыкания **сохраняют ссылку на переменные**, а не копию.
* Если внешняя переменная изменяется, все замыкания видят новое значение:

```go
var funcs []func()
for i := 0; i < 3; i++ {
    funcs = append(funcs, func() {
        fmt.Println(i)
    })
}

for _, f := range funcs {
    f() // 3 3 3 — все видят финальное значение i
}
```

* Чтобы этого избежать, нужно **создать локальную копию** переменной внутри цикла:

```go
for i := 0; i < 3; i++ {
    x := i
    funcs = append(funcs, func() {
        fmt.Println(x)
    })
}

for _, f := range funcs {
    f() // 0 1 2
}
```

---

### Итого

* **Замыкание** — это функция, которая «помнит» переменные из внешней области.
* Позволяет хранить **состояние между вызовами**.
* Используется для **фабрик функций, генераторов и инкапсуляции данных**.
* Требует осторожности с циклами и ссылками на переменные.