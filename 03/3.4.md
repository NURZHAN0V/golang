# Указатели

В Go **указатели** позволяют хранить **адреса других переменных**. Это важно для передачи данных **по ссылке**, а не копированием, и для работы с изменяемыми структурами.

---

### Что такое указатель

* Указатель хранит **адрес памяти**, по которому находится значение.
* Тип указателя обозначается знаком `*` перед типом значения:

```go
var p *int
```

* Здесь `p` — указатель на `int`. Пока не присвоен адрес, он равен `nil`.

---

### Получение адреса переменной

Для получения адреса используется оператор `&`:

```go
x := 42
p := &x
fmt.Println(p)  // адрес переменной x
fmt.Println(*p) // значение переменной x через указатель: 42
```

* `*p` — это **разыменование** указателя, получение значения по адресу.

---

### Изменение значения через указатель

```go
x := 10
p := &x
*p = 20
fmt.Println(x) // 20
```

* Изменяя `*p`, мы изменяем **исходную переменную** `x`.

---

### Указатели и функции

Указатели позволяют **передавать данные по ссылке**:

```go
func increment(n *int) {
    *n = *n + 1
}

func main() {
    x := 5
    increment(&x)
    fmt.Println(x) // 6
}
```

* Если передавать переменную без указателя, функция получает **копию**, изменения не повлияют на оригинал.

---

### Нулевой указатель

* Указатель может быть равен `nil` — это значит, что он **не указывает ни на какую переменную**:

```go
var p *int
fmt.Println(p) // <nil>
```

* Перед разыменованием `nil`-указателя возникает **паника**. Всегда проверяйте:

```go
if p != nil {
    fmt.Println(*p)
}
```

---

### Указатели на структуры

* Указатели особенно полезны для работы со структурами (`struct`):

```go
type Person struct {
    Name string
    Age  int
}

func birthday(p *Person) {
    p.Age++
}

func main() {
    person := Person{"Олег", 30}
    birthday(&person)
    fmt.Println(person.Age) // 31
}
```

* Указатели позволяют **изменять поля структур без копирования всей структуры**.

---

### Указатели и массивы/срезы

* **Срезы** уже работают как указочные типы — передача в функцию изменяет исходные данные:

```go
nums := []int{1, 2, 3}
func double(s []int) {
    for i := range s {
        s[i] *= 2
    }
}
double(nums)
fmt.Println(nums) // [2 4 6]
```

* Массивы передаются **по значению**, указатель на массив позволяет изменять его содержимое:

```go
arr := [3]int{1, 2, 3}
func doubleArr(a *[3]int) {
    for i := range a {
        a[i] *= 2
    }
}
doubleArr(&arr)
fmt.Println(arr) // [2 4 6]
```

---

### Итого

* Указатели хранят **адрес переменной** и позволяют работать с данными напрямую.
* `&` — взять адрес, `*` — разыменовать.
* Позволяют **передавать данные по ссылке** в функции.
* Особо полезны при работе со структурами и массивами для **изменения оригинала без копирования**.
* Всегда проверяйте указатели на `nil` перед разыменованием.