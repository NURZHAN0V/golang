# Моки и тестовые двойники

При написании тестов часто возникает ситуация, когда **нужно проверить код, который зависит от внешних систем**: баз данных, HTTP-сервисов, файловой системы или других сложных компонентов.

В Go для таких случаев используют **моки и тестовые двойники** — объекты, которые имитируют поведение реальных зависимостей, но работают **быстро, предсказуемо и локально**.

---

### Зачем нужны моки

* Изолировать тестируемый код от внешних зависимостей.
* Сделать тесты **быстрыми и надёжными**.
* Возможность имитировать **разные сценарии ошибок и успеха**.

Например, вместо подключения к реальной базе данных можно создать мок, который возвращает заранее подготовленные данные.

---

### Пример интерфейса и мока

```go
package main

import (
    "errors"
    "testing"
)

// Интерфейс хранилища
type Store interface {
    GetUser(id int) (string, error)
}

// Реальная функция, которая использует Store
func GreetUser(s Store, id int) (string, error) {
    name, err := s.GetUser(id)
    if err != nil {
        return "", err
    }
    return "Привет, " + name, nil
}

// Мок хранилища для теста
type MockStore struct{}

func (m MockStore) GetUser(id int) (string, error) {
    if id == 0 {
        return "", errors.New("пользователь не найден")
    }
    return "Олег", nil
}

func TestGreetUser(t *testing.T) {
    store := MockStore{}

    greeting, err := GreetUser(store, 1)
    if err != nil {
        t.Fatal(err)
    }

    expected := "Привет, Олег"
    if greeting != expected {
        t.Errorf("ожидали %q, получили %q", expected, greeting)
    }
}
```

* `MockStore` реализует интерфейс `Store` и **имитирует поведение настоящего хранилища**.
* Тесты становятся **быстрыми, простыми и предсказуемыми**.

---

### Советы по созданию тестовых двойников

1. **Интерфейсы облегчают моки**. Любой внешний компонент, который может быть заменён на мок, лучше описывать через интерфейс.
2. **Имитация ошибок** — важная часть тестов. Проверьте, что код корректно обрабатывает ошибки внешних сервисов.
3. Можно использовать **библиотеки для моков**, например:

* `gomock` — официальная библиотека с генерацией моков.
* `testify/mock` — удобная библиотека с простым синтаксисом.

---

### Итого

* Моки и тестовые двойники позволяют **изолировать тестируемый код от внешнего окружения**.
* Используются интерфейсы для имитации зависимостей.
* Делают тесты **быстрыми, безопасными и управляемыми**.
* Позволяют проверять **разные сценарии, включая ошибки внешних систем**.