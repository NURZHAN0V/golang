# Бенчмарки

Бенчмарки позволяют **измерять производительность функций** и понимать, сколько времени занимает выполнение кода. В Go встроена поддержка бенчмарков через пакет **`testing`**. Это особенно полезно, когда нужно оптимизировать критические участки программы.

---

### Создание простого бенчмарка

```go
package main

import (
    "testing"
)

func Add(a, b int) int {
    return a + b
}

func BenchmarkAdd(b *testing.B) {
    for i := 0; i < b.N; i++ {
        Add(2, 3)
    }
}
```

* Функция бенчмарка должна начинаться с `Benchmark` и принимать параметр `*testing.B`.
* `b.N` — число итераций, которое Go подбирает автоматически для получения точного времени.
* В цикле выполняется код, который нужно измерить.

---

### Запуск бенчмарков

```bash
go test -bench=.
```

* Флаг `-bench=.` означает, что Go запустит **все бенчмарки** в пакете.
* Вывод будет примерно такой:

```
BenchmarkAdd-8    1000000000               0.234 ns/op
```

* `-8` — количество потоков, используемых Go.
* `ns/op` — наносекунды на одну операцию.

---

### Советы для бенчмарков

* **Измеряйте только то, что нужно**: не включайте подготовку данных в цикл бенчмарка, если она не относится к измеряемой операции.
* **Используйте `b.ResetTimer()`**, чтобы сбросить таймер после подготовки данных:

```go
func BenchmarkAddWithSetup(b *testing.B) {
    a, c := 2, 3
    b.ResetTimer() // начинаем измерять только саму функцию
    for i := 0; i < b.N; i++ {
        Add(a, c)
    }
}
```

* Можно измерять **разные реализации функции**, чтобы сравнивать производительность.

---

### Бенчмарки и параллелизм

Go позволяет запускать бенчмарки **параллельно**, что полезно для измерения производительности конкурентного кода:

```go
func BenchmarkAddParallel(b *testing.B) {
    b.RunParallel(func(pb *testing.PB) {
        for pb.Next() {
            Add(2, 3)
        }
    })
}
```

* `b.RunParallel` создаёт несколько горутин и выполняет код параллельно.
* Позволяет проверить, как функция работает в многопоточной среде.

---

### Итого

* Бенчмарки — **инструмент для измерения скорости и производительности кода**.
* Используются функции с префиксом `Benchmark` и параметром `*testing.B`.
* Go автоматически подбирает количество итераций `b.N` для точности измерений.
* Поддерживаются **параллельные бенчмарки** и гибкая настройка.