# race detector

При работе с конкурентным кодом легко допустить **гонки данных** (data race) — ситуацию, когда несколько горутин одновременно читают и записывают одну и ту же переменную без синхронизации. Такие ошибки трудно отлавливать, потому что программа может вести себя непредсказуемо.

Go предоставляет **встроенный инструмент для обнаружения гонок** — **race detector**.

---

### Как включить race detector

При запуске программы или тестов добавьте флаг `-race`:

```bash
go run -race main.go
go test -race ./...
```

* Флаг активирует **специальную проверку памяти** на наличие гонок.
* Go отслеживает **одновременный доступ к переменным**, чтобы найти потенциальные ошибки.

---

### Пример гонки данных

```go
package main

import (
    "fmt"
    "sync"
)

func main() {
    counter := 0

    var wg sync.WaitGroup
    wg.Add(2)

    go func() {
        counter++
        wg.Done()
    }()

    go func() {
        counter++
        wg.Done()
    }()

    wg.Wait()
    fmt.Println("Counter:", counter)
}
```

* Две горутины одновременно увеличивают `counter`.
* Без синхронизации результат может быть непредсказуемым (1 или 2 вместо ожидаемых 2).
* При запуске с `-race` Go выдаст предупреждение о гонке данных.

---

### Как исправить гонки

1. **Использовать мьютексы (`sync.Mutex`)**:

```go
var mu sync.Mutex
mu.Lock()
counter++
mu.Unlock()
```

2. **Использовать каналы для синхронизации**:

```go
ch := make(chan int)
go func() { ch <- counter + 1 }()
counter = <-ch
```

* race detector помогает выявить именно те участки кода, где гонка происходит, чтобы их исправить.

---

### Итого

* **race detector** — встроенный инструмент Go для поиска **гонок данных**.
* Запускается с флагом `-race` при `go run` или `go test`.
* Очень полезен при работе с горутинами и конкурентными структурами.
* Выявляет ошибки, которые сложно заметить обычным тестированием.