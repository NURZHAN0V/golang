# Табличные тесты

Когда у функции много похожих сценариев для проверки, писать отдельный тест на каждый случай становится **долго и неудобно**. В Go для таких случаев есть **табличные тесты** — компактный и читаемый способ проверять множество входных данных и ожидаемых результатов в одной структуре.

---

### Пример табличного теста

```go
package main

import (
    "testing"
)

func Add(a, b int) int {
    return a + b
}

func TestAddTable(t *testing.T) {
    tests := []struct {
        name     string
        a, b     int
        expected int
    }{
        {"положительные числа", 2, 3, 5},
        {"отрицательные числа", -1, -2, -3},
        {"смешанные числа", -1, 2, 1},
        {"нулевой случай", 0, 0, 0},
    }

    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            result := Add(tt.a, tt.b)
            if result != tt.expected {
                t.Errorf("Add(%d, %d) = %d; хотели %d", tt.a, tt.b, result, tt.expected)
            }
        })
    }
}
```

* `tests` — срез структур, каждая структура описывает **отдельный тестовый случай**.
* `t.Run(tt.name, func(t *testing.T) {...})` — запускает под-тест с названием, что удобно для отчётов и отладки.
* Все тесты проходят в одном файле и одном цикле, что делает код компактным и поддерживаемым.

---

### Почему табличные тесты удобны

* **Компактность**: не нужно дублировать один и тот же код проверки для разных сценариев.
* **Читаемость**: каждый тестовый случай имеет своё название (`name`).
* **Масштабируемость**: легко добавлять новые сценарии — достаточно добавить ещё элемент в таблицу.
* **Совместимость с `go test`**: все под-тесты видны в отчётах, особенно с флагом `-v`.

---

### Запуск табличных тестов

```bash
go test -v
```

* В выводе видно каждый под-тест с названием и результатом (`PASS` или `FAIL`).
* Можно запускать конкретный под-тест:

```bash
go test -run TestAddTable/смешанные_числа
```

---

### Итого

* Табличные тесты — **лучший способ проверять функцию на множестве похожих случаев**.
* Используется **срез структур** с данными и ожидаемым результатом.
* `t.Run` позволяет **логично именовать и запускать каждый тест отдельно**.
* Хорошая практика: использовать табличные тесты для всех функций с множеством сценариев.