# Интерфейсы и их имплементация

В Go **интерфейсы (`interface`)** позволяют описывать **поведение**, которое должен реализовать тип. Это ключ к **гибкой архитектуре и полиморфизму**, без традиционного наследования.

---

### Что такое интерфейс

* Интерфейс — это набор **методов**, которые должен иметь тип, чтобы считаться его реализацией.

```go
type Greeter interface {
    Greet() string
}
```

* Любой тип, у которого есть метод `Greet() string`, автоматически реализует интерфейс `Greeter`.
* **Никакой явной декларации «implements» не требуется** — достаточно совпадения методов.

---

### Пример реализации интерфейса

```go
type Person struct {
    Name string
}

func (p Person) Greet() string {
    return "Привет, меня зовут " + p.Name
}

func SayHello(g Greeter) {
    fmt.Println(g.Greet())
}

p := Person{"Олег"}
SayHello(p) // Привет, меня зовут Олег
```

* `Person` реализует интерфейс `Greeter`.
* Функция `SayHello` может работать с **любым типом**, который реализует `Greeter`.

---

### Интерфейс как тип

* Интерфейс — это **ссылка на значение и его метод**.
* Можно хранить разные типы в одной переменной интерфейса:

```go
var g Greeter
g = Person{"Анна"}
fmt.Println(g.Greet()) // Привет, меня зовут Анна
```

* Это позволяет **передавать и хранить объекты разных типов**, если они реализуют один и тот же интерфейс.

---

### Пустой интерфейс `interface{}`

* Пустой интерфейс **не имеет методов**, поэтому любой тип реализует его:

```go
var x interface{}
x = 42
x = "строка"
```

* Используется, когда нужно работать с **данными произвольного типа**.

---

### Проверка типа в интерфейсе

1. **Type assertion** — проверка типа переменной интерфейса:

```go
var g Greeter = Person{"Олег"}
p, ok := g.(Person)
if ok {
    fmt.Println("Это Person:", p.Name)
}
```

2. **Type switch** — удобный способ обработать несколько типов:

```go
switch v := g.(type) {
case Person:
    fmt.Println("Person:", v.Name)
default:
    fmt.Println("Другой тип")
}
```

---

### Интерфейсы и указатели

* Методы с приёмником-указателем позволяют изменять данные.
* Чтобы тип реализовал интерфейс, сигнатуры методов должны совпадать с интерфейсом:

```go
type Incrementer interface {
    Inc()
}

type Counter struct {
    Value int
}

func (c *Counter) Inc() {
    c.Value++
}

var inc Incrementer = &Counter{10}
inc.Inc()
fmt.Println(inc.(*Counter).Value) // 11
```

* Здесь важно передавать **указатель**, иначе метод с приёмником-указателем не будет совпадать с интерфейсом.

---

### Итого

* Интерфейс описывает **поведение типа**, а не данные.
* Любой тип с нужными методами **автоматически реализует интерфейс**.
* Интерфейсы позволяют писать **универсальный и расширяемый код**.
* Пустой интерфейс `interface{}` подходит для работы с любыми типами.
* Методы с указателем или значением влияют на то, **как тип реализует интерфейс**.