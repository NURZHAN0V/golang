# Ошибки как значения (`error`)

В Go **ошибки — это обычные значения**, а не исключения, как в других языках. Такой подход делает обработку ошибок **явной, безопасной и понятной**.

---

### Что такое `error`

`error` — это встроенный интерфейс:

```go
type error interface {
    Error() string
}
```

* Любое значение, которое реализует метод `Error() string`, считается ошибкой.
* Go-функции обычно **возвращают ошибку как отдельное значение**, рядом с результатом.

---

### Пример функции с ошибкой

```go
package main

import (
    "errors"
    "fmt"
)

func divide(a, b float64) (float64, error) {
    if b == 0 {
        return 0, errors.New("деление на ноль запрещено")
    }
    return a / b, nil
}

func main() {
    result, err := divide(10, 0)
    if err != nil {
        fmt.Println("Ошибка:", err)
        return
    }
    fmt.Println("Результат:", result)
}
```

* Функция `divide` возвращает **два значения**: результат и ошибку.
* Если всё в порядке, ошибка равна `nil`.
* Если возникла проблема, ошибка содержит сообщение.

---

### Создание ошибки

1. **Стандартная библиотека**: `errors.New("сообщение")`

```go
err := errors.New("что-то пошло не так")
```

2. **Форматированное сообщение**: `fmt.Errorf`

```go
val := 42
err := fmt.Errorf("значение %d недопустимо", val)
```

---

### Проверка ошибки

* Всегда проверяйте возвращаемое значение `error` перед использованием результата:

```go
result, err := divide(10, 2)
if err != nil {
    fmt.Println("Ошибка:", err)
    return
}
fmt.Println("Результат:", result)
```

* Такой стиль делает код **безопасным и предсказуемым**.

---

### Создание собственных типов ошибок

Можно определять **свои структуры ошибок** с дополнительной информацией:

```go
type MyError struct {
    Code int
    Msg  string
}

func (e MyError) Error() string {
    return fmt.Sprintf("Ошибка %d: %s", e.Code, e.Msg)
}

func riskyOperation() error {
    return MyError{Code: 404, Msg: "не найдено"}
}

func main() {
    err := riskyOperation()
    if err != nil {
        fmt.Println(err)
    }
}
```

* Это полезно для сложных приложений, где нужно передавать **код ошибки и детали**.

---

### Паника vs ошибка

* В Go есть `panic`, которое прерывает выполнение программы.
* **Не рекомендуется использовать `panic` для обычных ошибок**.
* `error` — безопасный способ сообщить о проблеме и продолжить работу.

---

### Итого

* В Go **ошибки — это значения**, которые возвращаются функциями.
* Используются стандартный интерфейс `error`, `errors.New` и `fmt.Errorf`.
* Всегда проверяйте `error` перед использованием результатов функции.
* Для сложных ошибок можно создавать собственные типы, реализующие `Error() string`.
* `panic` предназначен для **неожиданных ситуаций**, а обычные ошибки обрабатываются через `error`.