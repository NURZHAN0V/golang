# 1.9 –î–∂–µ–Ω–µ—Ä–∏–∫–∏ (type parameters)

> –î–∂–µ–Ω–µ—Ä–∏–∫–∏ –ø—Ä–∏—à–ª–∏ –≤ Go 1.18: —Ç–µ–ø–µ—Ä—å –º–æ–∂–Ω–æ –ø–∏—Å–∞—Ç—å —Ñ—É–Ω–∫—Ü–∏–∏ –∏ —Ç–∏–ø—ã, –∫–æ—Ç–æ—Ä—ã–µ —Ä–∞–±–æ—Ç–∞—é—Ç —Å —Ä–∞–∑–Ω—ã–º–∏ —Ç–∏–ø–∞–º–∏ –¥–∞–Ω–Ω—ã—Ö, —Å–æ—Ö—Ä–∞–Ω—è—è —Å—Ç—Ä–æ–≥—É—é —Ç–∏–ø–∏–∑–∞—Ü–∏—é.

## 1. –ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–π –ø—Ä–∏–º–µ—Ä `min`
```go
package main
import "constraints" // —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π –ø–∞–∫–µ—Ç

func Min[T constraints.Ordered](a, b T) T {
    if a < b {
        return a
    }
    return b
}

func main() {
    fmt.Println(Min(3, 7))       // int
    fmt.Println(Min(2.2, 1.9))   // float64
    fmt.Println(Min('b', 'a'))   // rune
}
```
`T` ‚Äî –ø–∞—Ä–∞–º–µ—Ç—Ä —Ç–∏–ø–∞. `constraints.Ordered` —Ç—Ä–µ–±—É–µ—Ç, —á—Ç–æ–±—ã —Ç–∏–ø –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–ª `<` `<=` `>` `>=`.

## 2. –û–±–æ–±—â—ë–Ω–Ω—ã–π —Å—Ç–µ–∫
```go
type Stack[T any] struct {
    items []T
}
func (s *Stack[T]) Push(v T) { s.items = append(s.items, v) }
func (s *Stack[T]) Pop() (T, bool) {
    if len(s.items) == 0 {
        var zero T
        return zero, false
    }
    i := len(s.items) - 1
    v := s.items[i]
    s.items = s.items[:i]
    return v, true
}
```
–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ:
```go
var s Stack[string]
s.Push("hi")
val, _ := s.Pop()
fmt.Println(val)
```

## 3. –°–≤–æ–∏ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è (constraint)
```go
type Adder interface {
    ~int | ~int64 | ~float64 // —Ç–∏–ª—å–¥–∞ = –≤—Å–µ —Ç–∏–ø—ã, —á—å–∏–º –±–∞–∑–æ–≤—ã–º —è–≤–ª—è–µ—Ç—Å—è int/int64/float64
}

func Sum[T Adder](vals []T) (total T) {
    for _, v := range vals {
        total += v
    }
    return
}
```

## 4. Type inference
Go —á–∞—â–µ –≤—Å–µ–≥–æ –≤—ã–≤–æ–¥–∏—Ç `T` –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏:
```go
fmt.Println(Sum([]int{1,2,3}))     // T == int
fmt.Println(Sum([]int64{1,2,3}))   // T == int64
```
–ú–æ–∂–Ω–æ –∏ —è–≤–Ω–æ: `Sum[int64](...)`.

## 5. –ö–æ–≥–¥–∞ –¥–∂–µ–Ω–µ—Ä–∏–∫–∏ –ø–æ–ª–µ–∑–Ω—ã?
1. –ö–æ–Ω—Ç–µ–π–Ω–µ—Ä—ã: —Å—Ç–µ–∫–∏, –æ—á–µ—Ä–µ–¥–∏, —Ö–µ—à-—Ç–∞–±–ª–∏—Ü—ã.  
2. –£—Ç–∏–ª–∏—Ç—ã: `maps`, `slices` –∏–∑ stdlib 1.21+.  
3. –ò–∑–±–µ–∂–∞—Ç—å `interface{}` –∏ –∫–∞—Å—Ç–æ–≤.

> –ù–µ –∑–ª–æ—É–ø–æ—Ç—Ä–µ–±–ª—è–π—Ç–µ: –µ—Å–ª–∏ —Ñ—É–Ω–∫—Ü–∏—è —Å–ø–µ—Ü–∏—Ñ–∏—á–Ω–∞ –¥–ª—è `string`, –Ω–µ –¥–µ–ª–∞–π—Ç–µ –µ—ë –æ–±–æ–±—â—ë–Ω–Ω–æ–π.

## –£–ø—Ä–∞–∂–Ω–µ–Ω–∏—è üìù
1. –†–µ–∞–ª–∏–∑—É–π—Ç–µ –æ–±–æ–±—â—ë–Ω–Ω—É—é —Ñ—É–Ω–∫—Ü–∏—é `Reverse[T any](in []T) []T`.
2. –ù–∞–ø–∏—à–∏—Ç–µ —Ç–∏–ø `Pair[K comparable, V any]` —Å –º–µ—Ç–æ–¥–æ–º `String() string`, –∫–æ—Ç–æ—Ä—ã–π –≤—ã–≤–æ–¥–∏—Ç `<K:V>`.
3. –ò—Å–ø–æ–ª—å–∑—É—è `constraints.Integer`, —Å–æ–∑–¥–∞–π—Ç–µ —Ñ—É–Ω–∫—Ü–∏—é `Clamp[T constraints.Integer](v, min, max T) T`, –æ–≥—Ä–∞–Ω–∏—á–∏–≤–∞—é—â—É—é –∑–Ω–∞—á–µ–Ω–∏–µ –¥–∏–∞–ø–∞–∑–æ–Ω–æ–º.
