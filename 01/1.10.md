# 1.10 –ö–æ–Ω–∫—É—Ä–µ–Ω—Ç–Ω–æ—Å—Ç—å: goroutine, –∫–∞–Ω–∞–ª—ã, `select`

> –í Go –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω–æ—Å—Ç—å –ø–æ—Å—Ç—Ä–æ–µ–Ω–∞ –Ω–∞ –ª—ë–≥–∫–∏—Ö –ø–æ—Ç–æ–∫–∞—Ö ‚Äî **goroutine** ‚Äî –∏ –∫–∞–Ω–∞–ª–∞—Ö –¥–ª—è –æ–±—â–µ–Ω–∏—è –º–µ–∂–¥—É –Ω–∏–º–∏. –î–µ–≤–∏–∑: *–ù–µ —Å–≤—è–∑—ã–≤–∞–π—Ç–µ –¥–∞–Ω–Ω—ã–µ —Å –ø–æ–º–æ—â—å—é –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö, —Å–≤—è–∑—ã–≤–∞–π—Ç–µ –∏—Ö —Å –ø–æ–º–æ—â—å—é –∫–æ–º–º—É–Ω–∏–∫–∞—Ü–∏–π*.

## 1. Goroutine ‚Äì ¬´–∑–µ–ª—ë–Ω–∞—è¬ª –Ω–∏—Ç–æ—á–∫–∞
```go
func worker(id int) {
    fmt.Printf("worker %d started\n", id)
    time.Sleep(time.Second)
    fmt.Printf("worker %d done\n", id)
}

for i := 1; i <= 3; i++ {
    go worker(i) // –∫–ª—é—á–µ–≤–æ–µ —Å–ª–æ–≤–æ go
}

time.Sleep(2 * time.Second) // –∂–¥—ë–º –≥–æ—Ä—É—Ç–∏–Ω—ã
```
–í—ã–≤–æ–¥ (–ø–æ—Ä—è–¥–æ–∫ –º–æ–∂–µ—Ç –æ—Ç–ª–∏—á–∞—Ç—å—Å—è):
```
worker 1 started
worker 2 started
worker 3 started
worker 1 done
worker 2 done
worker 3 done
```
> –ë–µ–∑ –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ `Sleep` –ø—Ä–æ–≥—Ä–∞–º–º–∞ –±—ã –∑–∞–≤–µ—Ä—à–∏–ª–∞—Å—å, –Ω–µ —É—Å–ø–µ–≤ –¥–æ–∂–¥–∞—Ç—å—Å—è –≥–æ—Ä—É—Ç–∏–Ω.

## 2. –ö–∞–Ω–∞–ª—ã ‚Äì –±–µ–∑–æ–ø–∞—Å–Ω–∞—è –ø–µ—Ä–µ–¥–∞—á–∞ –¥–∞–Ω–Ω—ã—Ö
```go
ch := make(chan int)

// –æ—Ç–ø—Ä–∞–≤–∏—Ç–µ–ª—å
go func() {
    ch <- 42 // –∫–ª–∞–¥—ë–º –∑–Ω–∞—á–µ–Ω–∏–µ
}()

// –ø–æ–ª—É—á–∞—Ç–µ–ª—å
v := <-ch
fmt.Println(v) // 42
```

### –ë—É—Ñ–µ—Ä–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –∫–∞–Ω–∞–ª
```go
buf := make(chan string, 2)
buf <- "a"
buf <- "b"
```
–ï—Å–ª–∏ –±—É—Ñ–µ—Ä –∑–∞–ø–æ–ª–Ω–µ–Ω, –æ—Ç–ø—Ä–∞–≤–∏—Ç–µ–ª—å –±–ª–æ–∫–∏—Ä—É–µ—Ç—Å—è.

### –ó–∞–∫—Ä—ã—Ç–∏–µ –∫–∞–Ω–∞–ª–∞
```go
close(ch)
if v, ok := <-ch; !ok {
    fmt.Println("–∫–∞–Ω–∞–ª –∑–∞–∫—Ä—ã—Ç")
}
```

## 3. `select` ‚Äì –º–Ω–æ–≥–æ–∫–∞–Ω–∞–ª—å–Ω—ã–π –ø—Ä–∏—ë–º
```go
select {
case msg := <-ch1:
    fmt.Println("ch1", msg)
case msg := <-ch2:
    fmt.Println("ch2", msg)
default:
    fmt.Println("–Ω–∏—á–µ–≥–æ –Ω–µ –≥–æ—Ç–æ–≤–æ")
}
```
`select` –æ–∂–∏–¥–∞–µ—Ç –ø–µ—Ä–≤—ã–π –≥–æ—Ç–æ–≤—ã–π case; `default` —Å—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –Ω–µ–º–µ–¥–ª–µ–Ω–Ω–æ, –µ—Å–ª–∏ –Ω–∏—á–µ–≥–æ –Ω–µ –≥–æ—Ç–æ–≤–æ.

## 4. Fan-in / Fan-out
```go
func producer(id int, out chan<- int) { /*...*/ }
func consumer(in <-chan int, wg *sync.WaitGroup) { /*...*/ }
```
–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è `chan<-` (—Ç–æ–ª—å–∫–æ –æ—Ç–ø—Ä–∞–≤–∫–∞) –∏ `<-chan` (—Ç–æ–ª—å–∫–æ —á—Ç–µ–Ω–∏–µ) –¥–ª—è –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏–∏ –∏ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏.

## 5. –ü—Ä–∏–º–µ—Ä: —Å—á—ë—Ç—á–∏–∫ —Å–ª–æ–≤ –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω–æ
```go
func wordCount(path string) (map[string]int, error) {
    data, err := os.ReadFile(path)
    if err != nil { return nil, err }
    words := strings.Fields(string(data))

    workers := 4
    chunk := len(words)/workers
    out := make(chan map[string]int, workers)

    for i := 0; i < workers; i++ {
        start := i * chunk
        end := start + chunk
        if i == workers-1 { end = len(words) }
        go func(part []string) {
            m := make(map[string]int)
            for _, w := range part {
                m[w]++
            }
            out <- m
        }(words[start:end])
    }

    result := make(map[string]int)
    for i := 0; i < workers; i++ {
        for w, c := range <-out {
            result[w] += c
        }
    }
    return result, nil
}
```

## –£–ø—Ä–∞–∂–Ω–µ–Ω–∏—è üìù
1. –ù–∞–ø–∏—à–∏—Ç–µ –ø—Ä–æ–≥—Ä–∞–º–º—É, –∫–æ—Ç–æ—Ä–∞—è –∑–∞–ø—É—Å–∫–∞–µ—Ç 5 –≥–æ—Ä—É—Ç–∏–Ω; –∫–∞–∂–¥–∞—è –ø–µ—á–∞—Ç–∞–µ—Ç —Å–≤–æ–π –Ω–æ–º–µ—Ä –∏ –∫–≤–∞–¥—Ä–∞—Ç —á–∏—Å–ª–∞ (–∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–∞–Ω–∞–ª –¥–ª—è —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏–∏ –æ–∫–æ–Ω—á–∞–Ω–∏—è).
2. –†–µ–∞–ª–∏–∑—É–π—Ç–µ —Ç–∞–π–º–∞—É—Ç: –≥–æ—Ä—É—Ç–∏–Ω–∞ –∂–¥—ë—Ç –Ω–∞ –∫–∞–Ω–∞–ª–µ 3 —Å, –ø–æ—Ç–æ–º –≤—ã–≤–æ–¥–∏—Ç ¬´timeout¬ª. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ `select` —Å `time.After`.
3. –°–æ–∑–¥–∞–π—Ç–µ –∫–æ–Ω–≤–µ–π–µ—Ä (pipeline) –∏–∑ —Ç—Ä—ë—Ö –≥–æ—Ä—É—Ç–∏–Ω: –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä —á–∏—Å–µ–ª 1‚Ä¶n, —Ñ–∏–ª—å—Ç—Ä —á—ë—Ç–Ω—ã—Ö, –ø–µ—á–∞—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞.
