# Рефлексия (reflect)

**Рефлексия** — это возможность программы исследовать собственные переменные во время выполнения (runtime).
В Go для этого используется пакет [`reflect`](https://pkg.go.dev/reflect).

С помощью рефлексии можно:

* Узнавать тип и значение переменной во время выполнения.
* Динамически изменять значения.
* Строить универсальные функции (например, сериализацию, валидацию).

---

### Основные понятия

В пакете `reflect` есть два ключевых типа:

* `reflect.Type` — информация о типе (например, `int`, `string`, `struct`).
* `reflect.Value` — само значение, с которым можно работать.

---

### Пример: получение типа и значения

```go
package main

import (
    "fmt"
    "reflect"
)

func main() {
    x := 42
    t := reflect.TypeOf(x)
    v := reflect.ValueOf(x)

    fmt.Println("Тип:", t)         // int
    fmt.Println("Значение:", v)    // 42
}
```

---

### Изменение значения через рефлексию

Чтобы менять значения, нужно передавать указатель:

```go
package main

import (
    "fmt"
    "reflect"
)

func main() {
    x := 10
    v := reflect.ValueOf(&x).Elem() // получаем доступ к самому x

    if v.CanSet() {
        v.SetInt(99)
    }

    fmt.Println("Новое значение:", x) // 99
}
```

---

### Работа со структурами

Рефлексия позволяет динамически обходить поля структур:

```go
type User struct {
    Name string
    Age  int
}

func PrintFields(i interface{}) {
    v := reflect.ValueOf(i)
    t := v.Type()

    for i := 0; i < v.NumField(); i++ {
        fmt.Printf("Поле %s: %v\n", t.Field(i).Name, v.Field(i).Interface())
    }
}

func main() {
    u := User{"Alice", 30}
    PrintFields(u)
}
```

Вывод:

```
Поле Name: Alice
Поле Age: 30
```

---

### Когда использовать рефлексию?

✅ Полезна для:

* сериализации (например, в JSON),
* ORM,
* валидации структур,
* написания универсальных библиотек.

⚠️ Но!

* Рефлексия медленнее обычного кода.
* Менее читаема.
* Злоупотреблять ею не стоит — используйте дженерики, когда это возможно.

---

### Итоги

* Пакет `reflect` позволяет работать с типами и значениями во время выполнения.
* Через `TypeOf` и `ValueOf` можно исследовать и изменять данные.
* Основное применение — универсальные библиотеки и инфраструктурный код.