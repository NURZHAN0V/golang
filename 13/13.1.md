# Дженерики (Go 1.18+)

До версии **Go 1.18** программисты часто дублировали код:
например, писали функции для `int`, `float64`, `string` отдельно.
С выходом дженериков стало возможно писать **обобщённый код**,
который работает с разными типами.

---

### Зачем нужны дженерики?

* Убирают дублирование кода.
* Повышают читаемость.
* Дают строгую типизацию (в отличие от `interface{}`).

---

### Простейший пример

Без дженериков:

```go
func MinInt(a, b int) int {
    if a < b {
        return a
    }
    return b
}

func MinFloat(a, b float64) float64 {
    if a < b {
        return a
    }
    return b
}
```

С дженериками:

```go
func Min[T int | float64](a, b T) T {
    if a < b {
        return a
    }
    return b
}
```

Теперь `Min` можно вызвать и для `int`, и для `float64`:

```go
fmt.Println(Min(3, 5))       // int
fmt.Println(Min(2.7, 1.3))   // float64
```

---

### Ограничения (constraints)

Можно ограничивать, какие типы подходят.
Для этого есть пакет `constraints` из `golang.org/x/exp/constraints`.

Пример:

```go
import "golang.org/x/exp/constraints"

func Sum[T constraints.Ordered](values []T) T {
    var result T
    for _, v := range values {
        result += v
    }
    return result
}
```

Функция работает для `int`, `float64`, `string` (так как строки тоже упорядочены).

---

### Дженерики в структурах

Можно объявлять обобщённые типы:

```go
type Stack[T any] struct {
    items []T
}

func (s *Stack[T]) Push(v T) {
    s.items = append(s.items, v)
}

func (s *Stack[T]) Pop() T {
    if len(s.items) == 0 {
        var zero T
        return zero
    }
    v := s.items[len(s.items)-1]
    s.items = s.items[:len(s.items)-1]
    return v
}
```

Использование:

```go
intStack := Stack[int]{}
intStack.Push(10)
intStack.Push(20)
fmt.Println(intStack.Pop()) // 20

strStack := Stack[string]{}
strStack.Push("hello")
strStack.Push("world")
fmt.Println(strStack.Pop()) // world
```

---

### Итоги

* Дженерики появились в **Go 1.18**.
* Позволяют писать универсальные функции и структуры.
* Используются через синтаксис `[T any]` или с ограничениями (`constraints.Ordered`).
* Сильно упрощают код и делают его более безопасным.