# Unsafe и низкоуровневые операции

Go — это язык с **жёсткой типизацией и безопасной памятью**.
Но иногда нужны операции «под капотом»: прямой доступ к памяти,
работа с указателями, преобразования несовместимых типов.

Для этого есть пакет [`unsafe`](https://pkg.go.dev/unsafe).
Использовать его стоит **только в исключительных случаях**,
потому что он **обходит систему безопасности Go**.

---

### Когда нужен `unsafe`?

* Работа с **низкоуровневыми структурами данных**.
* Взаимодействие с **C-библиотеками**.
* Оптимизация производительности (но редко оправдана).
* Системное программирование (драйверы, спец. протоколы).

---

### Основные возможности

* `unsafe.Sizeof(x)` → размер переменной в байтах.
* `unsafe.Alignof(x)` → выравнивание типа.
* `unsafe.Offsetof(x)` → смещение поля в структуре.
* Преобразование `uintptr` и `unsafe.Pointer` для прямого доступа к памяти.

---

### Пример: размер и выравнивание

```go
package main

import (
    "fmt"
    "unsafe"
)

type User struct {
    ID   int32
    Age  int16
    Flag bool
}

func main() {
    var u User
    fmt.Println("Size:", unsafe.Sizeof(u))   // общий размер
    fmt.Println("Align ID:", unsafe.Alignof(u.ID))
    fmt.Println("Offset Age:", unsafe.Offsetof(u.Age))
}
```

---

### Пример: доступ к памяти через `unsafe.Pointer`

```go
package main

import (
    "fmt"
    "unsafe"
)

func main() {
    x := 100
    p := unsafe.Pointer(&x)       // получаем "сырой" указатель
    px := (*int)(p)               // приводим обратно к *int
    *px = 200

    fmt.Println(x) // 200
}
```

---

### Опасности

⚠️ Почему `unsafe` называется unsafe?

* Нарушает гарантию безопасности Go.
* Может сломать программу на другой архитектуре.
* Сложно поддерживать и отлаживать.

Поэтому рекомендуется:

* Сначала пробовать обычный Go или `reflect`.
* Использовать `unsafe` только там, где **невозможно иначе**.

---

### Итоги

* Пакет `unsafe` позволяет работать с памятью напрямую.
* Доступны: `Sizeof`, `Alignof`, `Offsetof`, `Pointer`.
* Использовать стоит крайне осторожно.
* Подходит только для низкоуровневых задач (системное или высокопроизводительное ПО).