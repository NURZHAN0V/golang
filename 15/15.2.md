# Оптимизация памяти

Оптимизация памяти — это процесс **уменьшения потребления памяти программой и улучшения её эффективности**. В Go это особенно важно, потому что **каждая goroutine и объект в куче используют ресурсы**, а сборщик мусора (GC) тоже тратит время на очистку памяти.

---

### Основные источники расхода памяти

1. **Срезы и массивы**

   * Большие срезы занимают много памяти.
   * Частое увеличение срезов через `append` может создавать временные копии.

2. **Структуры и объекты**

   * Структуры с большим количеством полей занимают много места.
   * Использование указателей помогает избегать лишнего копирования.

3. **Кэширование и временные объекты**

   * Частое создание временных объектов увеличивает нагрузку на GC.

---

### Советы по оптимизации

1. **Использовать указатели, когда это имеет смысл**

   * Передача больших структур по указателю уменьшает расход памяти.

2. **Выбирать правильный тип данных**

   * Например, `int32` вместо `int64` для небольших чисел.

3. **Реиспользовать объекты**

   * Пул объектов через `sync.Pool` позволяет повторно использовать память.

4. **Контролировать рост срезов**

   * Если заранее известно количество элементов, использовать `make([]T, 0, n)` вместо пустого среза.

5. **Минимизировать временные объекты**

   * Стараться не создавать ненужные строки и срезы внутри горячих функций.

---

### Пример использования `sync.Pool`

```go
import (
    "fmt"
    "sync"
)

var bufPool = sync.Pool{
    New: func() any {
        return make([]byte, 1024) // 1KB буфер
    },
}

func main() {
    buf := bufPool.Get().([]byte) // получаем буфер из пула
    defer bufPool.Put(buf)        // возвращаем обратно

    fmt.Println("Using buffer of size", len(buf))
}
```

* `sync.Pool` помогает **избегать частого выделения памяти**.
* Особенно полезно для объектов, которые создаются и уничтожаются часто.

---

### Инструменты анализа

* **pprof (heap)** — позволяет увидеть, какие объекты занимают больше всего памяти.
* **runtime.MemStats** — встроенный пакет `runtime` показывает статистику использования памяти.

```go
import (
    "fmt"
    "runtime"
)

func printMemStats() {
    var m runtime.MemStats
    runtime.ReadMemStats(&m)
    fmt.Printf("Alloc = %v KB\n", m.Alloc/1024)
}
```

* Эти инструменты помогают понять, **где именно тратится память и какие объекты создают нагрузку**.

---

### Итог

* Оптимизация памяти — ключ к **быстрым и надёжным Go-программам**.
* Использование **правильных типов, указателей, пулов и анализа pprof** позволяет минимизировать расход памяти и нагрузку на сборщик мусора.
* Всегда полезно **профилировать и измерять**, прежде чем оптимизировать.