# go tool trace

`go tool trace` — это **мощный инструмент для анализа работы Go-программ**, который позволяет визуализировать **время выполнения, горутины, системные вызовы и работу сборщика мусора**. С его помощью можно понять, где программа тратит ресурсы и как улучшить производительность.

---

### Что такое go tool trace

* Инструмент создаёт **интерактивные трассировки работы программы**.
* Показывает **параллельное выполнение горутин, блокировки, syscalls и GC-паузы**.
* Позволяет выявлять **узкие места в конкурентных программах**.

---

### Как собрать трассировку

1. Импортируем пакет `runtime/trace` и создаём файл трассировки:

```go
package main

import (
    "fmt"
    "os"
    "runtime/trace"
)

func main() {
    f, err := os.Create("trace.out")
    if err != nil {
        panic(err)
    }
    defer f.Close()

    trace.Start(f)
    defer trace.Stop()

    // пример работы программы
    fmt.Println("Tracing Go program")
}
```

2. После запуска программы появится файл `trace.out`.

---

### Просмотр трассировки

```bash
go tool trace trace.out
```

* Откроется веб-интерфейс в браузере.
* Доступны следующие виды анализа:

  * **Goroutine analysis** — что делают горутины и как они блокируются.
  * **Network blocking profile** — задержки при сетевых операциях.
  * **Heap profile** — использование памяти и объекты в куче.
  * **Scheduler trace** — как планировщик распределяет горутины.
  * **Garbage collection** — паузы и работа сборщика мусора.

---

### Примеры полезного использования

* Определение **долгих блокировок** горутин.
* Анализ **конкурентного выполнения** нескольких функций.
* Понимание **нагрузки на CPU и задержек из-за GC**.

---

### Итог

* `go tool trace` позволяет **полностью увидеть поведение программы во времени**.
* Это особенно полезно для **параллельных и высоконагруженных приложений**.
* Комбинируя трассировку с профилированием (`pprof`), можно **точно выявить узкие места и оптимизировать код**.