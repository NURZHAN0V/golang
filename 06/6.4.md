# Синхронизация (`sync.Mutex`, `sync.WaitGroup`)

В Go, когда несколько горутин работают с **общими ресурсами**, может возникнуть ситуация, когда данные **повреждаются из-за одновременного доступа**. Для безопасной работы с общими ресурсами используют **синхронизацию**.

Два самых популярных инструмента: **`sync.Mutex`** и **`sync.WaitGroup`**.

---

### `sync.Mutex` — блокировка для безопасного доступа

* `Mutex` (mutual exclusion) используется, чтобы **разрешить только одной горутине работать с ресурсом одновременно**:

```go
var mu sync.Mutex
counter := 0

func increment() {
    mu.Lock()           // захватываем блокировку
    counter++           // безопасная операция
    mu.Unlock()         // освобождаем блокировку
}
```

* `Lock()` — захватывает mutex и блокирует другие горутины.

* `Unlock()` — освобождает mutex, позволяя другим горутинам продолжить работу.

* **Важно:** всегда вызывать `Unlock()`, иначе другие горутины заблокируются навсегда.

---

### Пример использования `Mutex`

```go
var mu sync.Mutex
counter := 0

func main() {
    for i := 0; i < 5; i++ {
        go func() {
            mu.Lock()
            counter++
            mu.Unlock()
        }()
    }
    time.Sleep(time.Second)
    fmt.Println("Counter:", counter)
}
```

* Без `Mutex` результат был бы непредсказуемым из-за **гонки данных (data race)**.

---

### `sync.WaitGroup` — ожидание завершения горутин

* `WaitGroup` позволяет **ждать, пока группа горутин завершит выполнение**:

```go
var wg sync.WaitGroup

func worker(id int) {
    defer wg.Done() // сообщаем о завершении работы
    fmt.Println("Worker", id, "выполняется")
    time.Sleep(time.Millisecond * 500)
}

func main() {
    for i := 1; i <= 3; i++ {
        wg.Add(1)       // увеличиваем счетчик горутин
        go worker(i)
    }
    wg.Wait()          // ждём, пока все горутины вызовут Done()
    fmt.Println("Все горутины завершены")
}
```

* `Add(n)` — увеличивает счетчик на `n`.
* `Done()` — уменьшает счетчик на 1.
* `Wait()` — блокирует выполнение до тех пор, пока счетчик не станет 0.

---

### Совместное использование `Mutex` и `WaitGroup`

* Очень часто `Mutex` используется **внутри горутин**, а `WaitGroup` — **для ожидания их завершения**:

```go
var mu sync.Mutex
var wg sync.WaitGroup
counter := 0

for i := 0; i < 5; i++ {
    wg.Add(1)
    go func() {
        defer wg.Done()
        mu.Lock()
        counter++
        mu.Unlock()
    }()
}

wg.Wait()
fmt.Println("Counter:", counter)
```

* Это **комбинированный подход**, позволяющий безопасно изменять общие данные и дожидаться завершения всех задач.

---

### Итого

* **`sync.Mutex`** — защищает данные от одновременного доступа нескольких горутин.
* **`sync.WaitGroup`** — позволяет ждать завершения группы горутин.
* Вместе они создают безопасную и удобную систему **синхронизации и управления конкурентностью** в Go.